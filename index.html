<!DOCTYPE html>
<html>
  <head>
    <title>PBD Linkage Sim</title>
    <style>
      body {
        margin: 0;
        background: #222;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
      }
      canvas {
        background: #333;
        box-shadow: 0 0 20px black;
      }
    </style>
  </head>
  <body>
    <canvas id="simCanvas" width="800" height="600"></canvas>

    <script src="index.js"></script>

    <script>
      // Wasmの準備ができたら呼ばれる
      Module.onRuntimeInitialized = function () {
        console.log("Wasm Loaded!");

        const canvas = document.getElementById("simCanvas");
        const ctx = canvas.getContext("2d");

        // C++の世界を生成
        const world = new Module.World();
        let isDragging = false;
        let draggedPointIndex = -1;

        // マウス座標をCanvas内の座標に変換する便利関数
        function getMousePos(canvas, evt) {
          const rect = canvas.getBoundingClientRect();
          return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top,
          };
        }

        // マウスを押した時
        canvas.addEventListener("mousedown", (e) => {
          const pos = getMousePos(canvas, e);

          // 全部の点をチェックして、マウスに近い点を探す
          // (点は2個しかないのでループでOK)
          let minDist = 20; // 半径20px以内なら掴めることにする
          let targetIndex = -1;

          for (let i = 0; i < 2; i++) {
            const px = world.getParticleX(i);
            const py = world.getParticleY(i);
            const dx = pos.x - px;
            const dy = pos.y - py;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < minDist) {
              minDist = dist;
              targetIndex = i;
            }
          }

          if (targetIndex !== -1) {
            isDragging = true;
            draggedPointIndex = targetIndex;
          }
        });

        // マウスを動かした時
        canvas.addEventListener("mousemove", (e) => {
          if (isDragging && draggedPointIndex !== -1) {
            const pos = getMousePos(canvas, e);
            // C++に「この点をここに移動させろ」と命令
            world.setParticlePos(draggedPointIndex, pos.x, pos.y);
          }
        });

        // マウスを離した時
        canvas.addEventListener("mouseup", () => {
          isDragging = false;
          draggedPointIndex = -1;
        });

        // マウスがキャンバス外に出た時も離したことにする
        canvas.addEventListener("mouseleave", () => {
          isDragging = false;
          draggedPointIndex = -1;
        });
        function loop() {
          world.update();
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // --- 1. リンク（棒）の描画 ---
          ctx.strokeStyle = "cyan";
          ctx.lineWidth = 4;
          const cCount = world.getConstraintCount();

          ctx.beginPath();
          for (let i = 0; i < cCount; i++) {
            const idx1 = world.getConstraintP1(i);
            const idx2 = world.getConstraintP2(i);
            const x1 = world.getParticleX(idx1);
            const y1 = world.getParticleY(idx1);
            const x2 = world.getParticleX(idx2);
            const y2 = world.getParticleY(idx2);

            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
          }
          ctx.stroke();

          // クランクの棒（0-1）は拘束リストに入ってないので手動描画
          ctx.strokeStyle = "yellow"; // モーター駆動部は黄色！
          ctx.beginPath();
          ctx.moveTo(world.getParticleX(0), world.getParticleY(0));
          ctx.lineTo(world.getParticleX(1), world.getParticleY(1));
          ctx.stroke();

          // --- 2. 点の描画 ---
          const pCount = world.getParticleCount();
          ctx.fillStyle = "white";
          for (let i = 0; i < pCount; i++) {
            const x = world.getParticleX(i);
            const y = world.getParticleY(i);
            ctx.beginPath();
            ctx.arc(x, y, i === 0 || i === 4 ? 5 : 10, 0, Math.PI * 2); // 固定点は小さく
            ctx.fill();
          }

          // --- 3. DOF表示 ---
          const dof = world.getDOF();
          ctx.fillStyle = "lime";
          ctx.font = "24px Arial";
          ctx.fillText("DOF: " + dof, 20, 40);

          requestAnimationFrame(loop);
        }

        loop();
      };
    </script>
  </body>
</html>
